# Redis服务器

> 说到Redis中的服务器，在前边讲客户端的时候也提到过Redis服务器的概念和模式。它的作用就是连接一个或多个Redis客户端并建立网络连接，处理客户端的命令请求并操作数据库，当然這些前提是要自身也能运转。

引言： 客户端命令请求执行的过程，以set k v ，并返回ok为例子进行

1. 客户端向服务端发送set k v 命令请求。
2. 服务端接受并处理，并使用数据库字典比对如果是可执行的就执行命令，返回命令回复为ok。
3. 服务端将ok发送给客户端。
4. 客户端将返回的信息打印

> 接下来就对这里面的实现细节进行逐步分析

## 客户端发送命令请求

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190403125640423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjA1OTY4,size_16,color_FFFFFF,t_70)

Redis中的客户端和服务器存在一种通信协议，发送命令的时候必须先转为该协议的格式然后才能把请求经服务端的套接字传给服务端。

## 读取命令请求

> 经过上一步操作，当客户端的写入使客户端和服务端连接的套接字变的可读时，服务端将调用命令处理器来处理请求。

命令处理器处理请求的步骤：

1. 读取该协议格式的请求，并将它保存在客户端的输入缓冲区里。
2. 对输入缓冲区的请求进行分析，提取请求中的参数和个数，放在客户端的argv和argc里（这个在讲客户端的时候说到过）。
3. 调用命令执行器执行命令。

## 命令执行器

（一） 查找命令L:命令执行器第一步就是要根据客户端的argv[0]参数，在命令表中查找命令，并保存到服务端的cmd属性中。命令表就是一个字典，字典的键就是命令名（里边都是命令名比如get，set等），值是redisCommand结构体。
   

``` 

typedef struct redisCommand {

//命令名如set，get等
char *name;
//函数指针，指向命令的实现函数
redisCommandProc *proc;
//记录命令参数的个数，用于检查格式是否正确，如果为-N，那就是可以接收N个或者以上的参数。
int  arity;
//记录了命令的属性的标志值，如读命令，写命令，载入命令等
char *sflags;
//由系统生成的对sflags标识进行分析得出的二进制标识
int flags;
//记录服务器一共执行了多少次这个命令
long long calls;
//服务器执行此命令耗费的时长
long long milliseconds;

}

```

下边的图是书上的一张图我感觉讲的很好

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190404223233948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjA1OTY4,size_16,color_FFFFFF,t_70)

第一张图是命令表的实现，第二张图是查找命令的实现。name为set说明命令名为set，proc执行的实现函数是setCommand，arity命令参数为-3没锁门可以接受三个或以上数量的参数，命令标识为“wm”说明是一个些操作。

（二） 执行预备操作

执行完第一步的命令查找并把找到的命令放在客户端cmd里（也就是上一张图的第二个表），接下来就要执行预备操作。

1. 查看cmd是否为空，若为空就不执行后边步骤。
2. 根据cmd指向的redisCommand的arity属性，判断参数个数正不正确。
3. 检查客户端是否通过了身份验证，如果未通过就只能执行AUTH命令(密码验证命令)，如果执行其他的命令就会报错。
4. 如果服务器打开maxmemory命令，在执行命令前会先检查服务器内存占用并在需要的时候进行回收，如果回收失败就不能进入下一步。
5. 若服务器上一次执行的BGSAVE出错时，并且服务器打开了stop-writes-on-bgsave-error功能（不能再BGSAVE出错时写），若此时执行写命令就会被拒接。
6. 若正使用SUBSCRIBE命令订阅频道或PSUBSCRIBE，UNSUBSCRIBE命令订阅模式，那服务器只会执行客户端法来的SUBCRIBE，PUNSUBSCRIBE，UNSUBCRIBE，PUNSUBSCRIBE，其余的命令都会拒绝。
7. 如果服务器因执行Lua而超时并进入阻塞，那服务器只会执行shutdown nosave和script kill，其余的都会拒绝。
8. 若客户端正在执行事务，那服务器只会执行客户端法来的exec，discard，multi，watch，其余的都会放进事务队列中。

> Redis在安全方面并没有做太大的优化，而是在性能和易用性方面下了很大的功夫。Redis一个很简单的安全方式就是密码验证，这需要用到AUTH命令，完成了上边的检查步骤就可以正式的执行命令了。

（三） 实现命令操作

在前文中提到过redisCommand结构体里的proc属性，它是用来执行命令的实现函数的，因此命令的实现也离不开它。

client->cmd->proc(client);//client是执行客户端状态的指针

所需要的参数都在客户端的argv中。成功后产生一个ok保存在在redisClient的buf中。

（四）执行后续操作

搞完了前几步，现在就进行一些后续的处理工作：

> 
Slow log 是 Redis 用来记录查询执行时间的日志系统。查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。

* 如果开启了慢日志功能，那慢日志模块检查需不需要给刚刚执行完的命令加一条慢查询日志。
* 根据耗费时长，更新redisCommand的milliseconds，并将call+1。
* 如果开启了AOF，那就把刚刚执行的命令写入的AOF缓冲区里。
* 如果有其他服务器正复制当前服务器，那当前服务器就会将刚刚执行的命令产拨给其他服务器。

## 将命令回复给客户端并在客户端进行打印

在命令实现函数会把返回的信息保存在redisClient的buf也就是客户端的输出缓冲区里，并为客户端的套接字关联回复处理器，当客户的套接字可写时，服务器就会执行回复处理器，并将客户端缓冲区信息发给给客户端（记住当前的信息格式还是协议格式），然后再经过客户端将协议格式转为人类可以理解的文字，然后打印给用户。

> 上边就是Redis客户端和服务端执行一次命令的过程了。

## serverCron函数

再前面的文章中也提到过serverCorn函数，自我感觉它就像一个管家，处理一些杂活和累活。下边就对它进行更详细的介绍。

* 更新服务器时间缓存

serverCorn每隔100毫秒对redisServer中的unixtime（秒级精度的时间戳）和mstime（毫秒精度的时间戳），因此可以得出它的时间精度并不高，因此它一般被用作在一些时间精度不需要太高的功能上如打印日志，LRU时钟更新等。

> 像设置过期时间，慢查询日志需要精度较高的，服务器会再次进行系统调用来获取最准确的时间。

* 更新LRU时钟

每个Redis对象都有一个lruclock属性，保存的是最后一次被访问的时间，lru每十秒更新一次用于计算空转时间（这个也都在前边说到过就不多说了），时钟当前值可以通过INFO server命令查看。

* 更新服务器每秒执行命令次数

以抽样的饭方式估算记录服务器在最近一秒处理请求的数量，可以用INFO status的instantaneous_ops_per_sec域查看。

* 更新服务器内存峰值记录

每次执行serverCron时，程序都会查看服务器当前使用的内存量并和峰值进行比较，如果比它大的话就记录起来。

* 处理sigterm信号

Redis会为sigterm信号关联处理器sigtermHandler函数，负责在服务端接受信号时打开服务器状态的shutdown_asap标识。

* 管理客户端资源

serverCron每次执行都会调用clientCron，对一定数量的客户端进行检查：如果服务端和客户端连接超时就释放客户端，如果客户端在上一次执行输入缓冲区的大小超过了一定长度，那么就会释放当前输入缓冲区，并重新创建一个默认大小的缓冲区，防止客户端缓冲区消耗过多内存。

* 管理数据库资源

serverCorn每次执行时都会嗲用databasesCorn，对服务器中一部分的数据库进行检测，删除过期键，在满足一定要求下，对字典进行收缩操作（在前面也都讲到过）。

* 执行被延迟的BGREWRITEAOF

在BGSAVE命令期间，如果客户端法来此命令那就会被延迟到BGSAVE完成后执行。

* 检查持久化操作的运行状态

redisServer中由rdb_child_pid和aof_child_pid记录执行BGSAVE命令和BGREWRITEAOF命令的子进程ID，当然也可以用来检查BGSAVE或者BGREWRITEAOF是否正在执行。serverCorn每执行一次都会检查这两个pid的值，只要其中一个不等于-1就执行wait操作，检查子进程是否有信号法来。

如果有信号，说明RDB文件生成完毕或AOF重写完毕，服务器执行相应的后续操作。（比如替换掉以前旧的RDB文件等），如果没信号，表示持久化未完成，程序不做动作。

如果rdb_child_pid和aof_child_pid都为-1（说明服务器没有进行任何持久化操作），程序会执行检查：

1. 是否有BGREWRITEAOF被延迟，有的话就开始一个新的AOF操作。
2. 如果没有被延迟的话，就检查自动保存的条件满不满足，若满足就执行BGSAVE。
3. 若不满足，就检查AOF重写条件是否满足，若满足就执行BGWRITEAOF，否则就不做动作。

* 将AOF缓冲区内容写入AOF

如果开启了AOF持久化功能，并且AOF缓冲区中还有待写入的数据，那serverCron就会调用相关函数把它写入到AOF文件里。

* 关闭异步服务器

关闭那些输出含冲去大小超过最大限制的客户端（在前面一篇由详解）

* 增加cornloops计数器的值。

cornloops保存了serverCorn中的次数。


## 服务器的初始化

### 第一阶段：初始化服务器状态结构

对server的初始化的工作由initServerConfig完成，在这个结构体里，主要做的事情就是：

1. 设置服务器运行的ID
2. 设置默认运行频率
3. 设置默认配置文件目录
4. 设置运行架构
5. 设置端口
6. 设置默认的RDB持久化和AOF持久化的条件
7. 初始化LRU时钟
8. 创建命令表
9. server.clients：记录所有客户端状态
10. server.db:包含了所有数据库
11. server.lua：执行Lua脚本的Lua环境
12. server.slowlog
13. server.pibsub_channels:保存模式订阅信息的链表等等配置

### 第二阶段：载入配置项

在initServerConfig初始化完server变量后，就会开始载入配置，配置可以进行手动更改，如果配置文件有变化的地方，那么这部分就按照改变后的来，其余若没手动变化的话就是默认值。

### 初始化服务器的数据结构

执行完上边后就开始对创建的数据结构进行初始化（分配内存，关联等），调用initServer。

除此之位initServer还进行一些重要操作：

1. 为服务器设置进程信号处理器
2. 创建共享对象
3. 打开服务端的监听端口，并为监听套接字关联应答时间处理器，以便于在服务器启动时接受客户端连接。
4. 为serverCorn创建时间事件，服务器正式运行时执行此函数。
5. 若AOF持久化功能已经打开，就打开现有的AOF，否则就重新创建一个AOF，为写入做好准备。
6. 初始化I/O模块。

### 还原数据库状态

创建关联并把资源都合理分配后，就根据一些列判断是否要还原上一次的数据库状态。

1. 判断服务器有没有启动AOF持久化，若启用了就使用AOF来还原。
2. 若没启用就使用RDB来还原数据库状态。
3. 若没有RDB那就为空的数据库。

### 执行事件循环

执行完上边这些步骤，服务器会打印准备接受连接，在此时初始化服务器的事件循环（loop）

> 到此，服务器的初始化就完成了。

