 # Redis中的事务

在Redis中也存在事务，通过MULTI，EXEC，WATCh等来实现，并且在Redis事务中没有回滚操作。

## 事务的实现

> 事务的实现过程可以分为三个步骤：事务的开始，事务命令入队，事务的执行。

### 事务的开始

当客户端接收到MULTI命令后就开启了事务，它将客户端从非事务状态转为事务状态。

使用一个flag变量来决定是不是事务状态。

### 命令入队

* 在客户端在非事务的状态下，你发出的指令会被立即执行
* 但是如果是在事务的状态下
       * 你发出的指令会保存在一个事务队列里面去。
       * 如果是EXEC，DISCARD，WATCH，MULTI其中之一，那服务器还是会立即执行这几种命令。（和事务相关的命令）

> 事务队列

下边是事务状态的redisClient的结构

```
typedef struct redisClient{

...

multiState master;//保存的事务的状态
...

}

```

multiState的结构

```

typedef struct multiState{

//事务队列，FIFO
multiCmd *commands;

//已经入队的个数
int count;

}

```

事务队列是一个multiCmd类型的数组,每一个节点的结构如下

```
typedef struct multiCmd{

robj **argv;

int argc;

struct redisCommand *cmd;

}

```

> 遵循队列的FIFO原则


### 事务的执行

当处于事务状态的客户都向服务器发送EXEC指令时，此指令会被服务器立即执行，然后服务器会遍历事务队列并执行指令。

EXEC根据代码可以归为以下流程：

1. 创建一个空的回复队列
2. 遍历事务队列，并读取每一个项的命令参数，个数和要执行的命令（并在循环内部依次执行命令，并将回复放在回复队列中去）
3. 在循环结束后，移除REDIS_MULTI标识，使客户端回到非事务的状态
4. 情况事务状态（事务队列，和事务技术）
5. 将执行结果返回给客户端

## WATCH命令

> wathc命令是一个乐观锁，它想的总是最好的一方面（悲观锁想的都是最不好的一面），它可以在EXEC执行之前队数据库中的任意数据键进行监控。

如果在EXEC执行时，会检查被监视的键有没有那个改变了，如果改变了，那这次EXEC也将会以失败而告终（返回一个空回复），如果还是保持原样，那就正常执行。

比如现在将时间分为5个时间片段，客户端A和客户都B都在执行命令

T1: 客户端A watch "name"
T2:客户端A multi
T3:客户端A set "name" "123"
T4:客户端B set "name" "abc"
T5:客户端A EXEC

> 服务器拒绝执行事务，结果返回空，说明被监视的值发生了改变。

### watch监听数据库键的原理

在Redis数据库中保存着一个watch_leys的字典， 这个字典的键是某个被watch命令监视的数据键，值是一个链表，保存的是某客户端监视某数据的客户端链表（也就是表示有哪些客户端监视了这个键）。

通过这个watch_keys字典，服务器可以很清楚了解到那个键正在被监听，和那些客户都正在监听这个键。

### 监听机制的触发

所有数据库的修改操作都会引起监视机制的触发，执行完修改操作（如：set，lpush，rpush，sadd等等）后会调用touchWatchkey函数对字典进行检查，如果发生改的话就，那么这个touchWatchKey就会把客户端的**REDIS_DIRTY_CAS标识打开**，表名该客户端的事务安全性已经被破坏。

### 判断事务是否安全

客户都向服务器发送EXEC命令，客户端查看REDIS_DIRTY_CAS是否打开，如果打开的话就拒绝客户端提交的事务，如果没打开正常执行。这样做是为了保证数据的安全性。

## 事务的四大特性

> 无论是那种数据库，事务都必须遵循ACID的四大特性

### 原子性(Atomicity)

数据库的多个操作看为一个整体，要么同时成功，要么同时失败。

说到原子性这块就不得不提到Redis不能回滚，因为Redis作者要保持Redis这种简单高效的宗旨，而且Redis的执行错误一般也就是命令错误，认为没必要回滚。

### 一致性（Consistency）

一致性是指在执行事务前后数据库的状态不发生改变，执行前是一致的执行后还是一致的。

> 一致指的是符合数据库本身的定义和要求，没有非法或无效的错误数据，下边几个原因可能会导致一致性上出错。

#### 入队错误

在开启事务之后，由于入队的命令格式或者命令不正确，会导致事务的失败。

#### 执行错误

* 这些错误一般就不是在入队前能被发现，只会在事务执行（命令执行）时触发。

* 这些出错的命令一般会被服务器识别出来并不去执行这些错误指令，不影响事务的执行。 

#### 服务器停机

* 如果在无持久化的情况下，重启后数据库是空白的，因此数据总是一致的

* 如果在RDB模式下，在事务执行期间停机也不会造成影响，因为可以根据RDB来恢复数据，从而将数据库还原位一致的状态。要是找不到RDB，那服务器就是空白的

* 如果在AOF模式下，也不会导致不一致，因为服务器可以根据现有的AOF来进行恢复，如果找不到AOF那就是是一个空白的


### 隔离性（Isolation）

指的是数据库由多个事务并发执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的结果是完全相同的。

### 持久性（Durability） 

事务的持久性就是在事务执行完毕时，执行这个事务的结果已经被保存到永久性储存介质里了，即使执行完毕后停机也不会丢失结果。

因为Redis中的事务就是一个简单的队列包裹起来的，因此事务不具有持久性，它的持久性取决于当前采用的模式：

* 如果没有采用持久化的话，那就再重启后会丢失所有数据。所以不具备持久性。
* 如果采用RDB持久化，服务器只会在满足保存条件下，才会执行BGSAVE命令，并且异步的执行不能保证事务产生的数据第一时间保存到硬盘里。所以不具备持久性。
* 当采用的是AOF持久化模式，并且将appendfsync的值设置为allways时，程序就在执行命令后调用同步函数（sync），将数据真正的保存在硬盘里，因此这种情况下是具有持久性的。
* 当在AOF持久化下，将appendsync设置为everysec（每秒依次）时，程序每秒同步一次。如果停机发生在等待同步的那一秒，也会造成事务数据丢失，所以也不具备持久性。
* 在AOF下，appendsync选项的值位no，程序会把同步数据这件事交给操作系统，因此也不具备持久性。

> no-appendfsync-on-rewrite:如果是打开状态，也就是不允许在执行BGSAVE和BGREWRITEAOF时对AOF进行同步，减小I/O阻塞。


> 总的来说，只有在AOF模式下，并且appendsync设置为allways才能具有持久性。但是也不是绝对的持久性，因为在no-appendsync-on-rewrite打开时，进行写操作就会暂停对AOF的同步。

也可以每打一条语句打一个save来保存，但是这样太繁琐了。

 